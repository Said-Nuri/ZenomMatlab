/* Function: xrt_Main ===========================================================
 * Abstract:
 *  Initialize the Simulink model pointed to by "model_name" and start
 *  model execution.
 *
 * Parameters :   
 *
 *  "model_name" is the entry point for the Simulink-generated code 

*  and is the same as the Simulink block diagram model name.     

 *  "priority" is the priority at which the model's highest priority task
 *  will run.  Other model tasks will run at successively lower priorities
 *  (i.e., high priority numbers).
 *------------------------------------------------*/
/*Xenomai Headers*/
#include <native/task.h>/*task management*/
#include <native/heap.h>/*shared memory*/
#include <native/cond.h>/*okunacak shm bölgesinin belirlenmesi*/
#include <native/mutex.h>
#include <native/event.h>
#include <native/queue.h>
#include <native/timer.h>

/*Hardware driver related headers   !!!! We need to find a better way to generalize this !!!!  */
#include "Q8Lib.h"

/*ANSI Headers*/
#include <stdio.h>
#include <getopt.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>

/*Linux Headers*/
#include <sys/mman.h>
#include <rtdk.h>
#include <signal.h>
#include <sys/io.h>

#define PIPE_MINOR 0
#define START_TARGET "--start" 
#define STOP_TARGET "--stops"
#define PAUSE_TARGET "--pause"
#define STOP_HOST    "--stops"
#define HOST_TERMINATED  "--termination"
#define TIME_ELAPSED     "--timeelapsed"
#define UPDATE_FREQDUR   "--updatefreqdur"
#define UNBIND_FROM_HOST "--unbind"
#define  BIND_TO_HOST "--bind"

//#define QUEUEUNBIND "--unbind"
//#define QUEUEBIND "--bind"
//#define QUEUEACTIVE "--active"


/*Real-Time Workshop headers*/
#include "rt_nonfinite.h"
#include "rtmodel.h"/*model_name.h dosyası include,(RT_MODEL)*/
#include "rtwtypes.h"/*real_T*/ 
#include "rtw_modelmap.h"/*rtwCAPI_ModelMappingInfo,mdl_info.h yerine*/
#include "rtw_capi.h"/*bio_sig.h ve pt_info.h yerine*/
#include "rt_sim.h"
#include "xeno_signallog.h"
//int xeno_UpdateBlockIOLogging(rtwCAPI_ModelMappingInfo* mmi, time_T *tPtr,double maxSize);



/*External Mode header*/
#ifdef EXT_MODE
#include "ext_work.h"
#include "rt_logging.h"//MAT-FILE
#endif



extern void MdlInitializeSizes(void);
extern void MdlInitializeSampleTimes(void);
extern void MdlStart(void);
extern void MdlOutputs(int_T tid);
extern void MdlUpdate(int_T tid);
extern void MdlTerminate(void);

#define INITIALIZE_SIZES(M)		MdlInitializeSizes()
#define INITIALIZE_SAMPLE_TIMES(M)	MdlInitializeSampleTimes()
#define START(M)			MdlStart()
#define OUTPUTS(M,tid)			MdlOutputs(tid)
#define UPDATED(M,tid)			MdlUpdate(tid)
#define TERMINATE(M)			MdlTerminate()             

#define RUN_FOREVER	        	-2.0
#define MAX_NAMES_SIZE			 81
#define MAX_DATA_SIZE            256
#define MAX_BUFFER_SIZE          81

#if NCSTATES > 0
  extern void rt_ODECreateIntegrationData(RTWSolverInfo *si);
  extern void rt_ODEUpdateContinuousStates(RTWSolverInfo *si);

# define rt_CreateIntegrationData(S) \
    rt_ODECreateIntegrationData(rtmGetRTWSolverInfo(S));
# define rt_UpdateContinuousStates(S) \
    rt_ODEUpdateContinuousStates(rtmGetRTWSolverInfo(S));
# else
# define rt_CreateIntegrationData(S)  \
      rtsiSetSolverName(rtmGetRTWSolverInfo(S),"FixedStepDiscrete");
# define rt_UpdateContinuousStates(S) \
      rtmSetT(S, rtsiGetSolverStopTime(rtmGetRTWSolverInfo(S)));
#endif


#define QUOTE1(name) #name
#define QUOTE(name) QUOTE1(name)    /* need to expand name    */

#define EXPAND_CONCAT(name1,name2) name1 ## name2
#define CONCAT(name1,name2) EXPAND_CONCAT(name1,name2)
#define RT_MODEL            CONCAT(MODEL,_rtModel)
#define NAMELENGTH 81

#define XSTR(x)    #x
#define STR(x)     XSTR(x)

#define MODELNAME_STORED "--nameOK"

/**
 * Zenom - Hard Real-Time Simulation Enviroment
 * @author
 *
 * znm_matlab
 *
 *
 */

#include <controlbase.h>
#include

class znm_matlab : public ControlBase
{
public:

    // ----- User Functions -----
    // This functions need to be implemented by the user.
    int initialize();
    int start();
    int doloop();
    int stop();
    int terminate();

private:
    // ----- Log Variables -----


    // ----- Control Variables -----


    // ----- Variables -----
};

/**
 * This function is called when the control program is loaded to zenom.
 * Use this function to register control parameters, to register log variables
 * and to initialize control parameters.
 *
 * @return Return non-zero to indicate an error.
 */
int znm_matlab::initialize()
{
     

    return 0;
}

/**
 * This function is called when the START button is pushed from zenom.
 *
 * @return If you return 0, the control starts and the doloop() function is
 * called periodically. If you return nonzero, the control will not start.
 */
int znm_matlab::start()
{


    return 0;
}


/**
 * This function is called periodically (as specified by the control frequency).
 * The useful functions that you can call used in doloop() are listed below.
 *
 * frequency()          returns frequency of simulation.
 * period()             returns period of simulation.
 * duration()           returns duration of simulation.
 * simTicks()           returns elapsed simulation ticks.
 * simTimeInNano()      returns elapsed simulation time in nano seconds.
 * simTimeInMiliSec()   returns elapsed simulation time in miliseconds.
 * simTimeInSec()       returns elapsed simulation time in seconds.
 * overruns()           returns the count of overruns.
 *
 * @return If you return 0, the control will continue to execute. If you return
 * nonzero, the control will abort and stop() function will be called.
 */
int znm_matlab::doloop()
{


    return 0;
}


/**
 * Called when a timed run ends or the STOP button is pushed from zenom.
 *
 * @return Return non-zero to indicate an error.
 */
int znm_matlab::stop()
{


    return 0;
}


/**
 * This function is called when the control is unloaded. It happens when
 * the user loads a new control program or exits.
 *
 * @return Return non-zero to indicate an error.
 */
int znm_matlab::terminate()
{


    return 0;
}


/**
 * The main function starts the control program
 */
int main( int argc, char *argv[] )
{
    znm_matlab c;
    c.run( argc, argv );

    return 0;
}











extern SignalBufferList *sbInfo;
extern SignalBuffer* sigBufs;
extern clean_Signals();

extern int fd;

static volatile bool susp   = false;
static volatile int endBaseRate   = 0;
static volatile int endHostInterface=0;
static volatile int endex=0;
static volatile int pauseBaseRate = 0; 
static volatile bool bindedToHost  = true;
static volatile bool firstRun=true;
static volatile bool cleaned=false;
static unsigned long long fileDesc=0;
static unsigned int xrtModelIndex=0;
int oc=0;
/*FLAGS FOR HARDWARE DRIVER MODULES*/

 int hw_install_flag=-1;
//bool national_instruments=false; 

void clean_up();

bool sigCleaned=0;

/*
 typedef enum requests{
	CONNECT_TO_TARGET,
	CONNECT_TO_TARGET_WITH_PROFILE,
	DISCONNECT_FROM_TARGET,
	START_TARGET,
	STOP_TARGET,
	UPDATE_PARAM,
	GET_TARGET_TIME,
	BATCH_DOWNLOAD,
	GET_PARAMS,
	CLOSE,
	CONNECT_TO_TARGET_RESPONSE,
	CONNECT_TO_TARGET_WITH_PROFILE_RESPONSE,
	DISCONNECT_FROM_TARGET_RESPONSE,
	START_TARGET_RESPONSE,
	STOP_TARGET_RESPONSE,
	UPDATE_PARAM_RESPONSE,
	GET_TARGET_TIME_RESPONSE,
	BATCH_DOWNLOAD_RESPONSE,
	GET_PARAMS_RESPONSE,
	CLOSE_RESPONSE       
} requestType;

requestType reqptr;
*/
typedef struct rtTargetParamInfo {
  char modelName[MAX_NAMES_SIZE];
  char blockName[MAX_NAMES_SIZE];
  char paramName[MAX_NAMES_SIZE];
  unsigned int numRows;
  unsigned int numColumns;
  unsigned int dataType;
  unsigned short isComplex;
  rtwCAPI_Orientation dataOrientation;/*scalar,vector,matrix*/
  double dataValue[MAX_DATA_SIZE];
} XrtTargetParamInfo;
/*
typedef struct rtModelName{
char modelName[MAX_NAMES_SIZE];

}XrtModelName;
*/
time_T modelTime;
RTIME checkBegin;
RTIME checkEnd;
RT_QUEUE q_Name;
RT_QUEUE q_Name2;


XrtTargetParamInfo *xrtpi;
void* sharedcon_mem;
double* controlHeap;
XrtModelName* modelNm;
void* shared_name;
#define TEVENT_SIGNAL_MASK 0x1
#define TEVENT_INIT        0x0           /* No flags present at init */
#define TEVENT_MODE        EV_ANY       /* Tasks will wait by priority order */
#define TEVENT_WAIT_MASK   (0x1) /* List of monitored events */
//#define EVENT_SIGNAL_MASK (0x2)         /* List of events to send */

#define STOP_TO_START_MASK  (0x10)

#define EVENT_INIT        0x0           /* No flags present at init */
#define EVENT_MODE        EV_PRIO       /* Tasks will wait by priority order */
#define EVENT_WAIT_MASK   (0x1|0x2|0x4) /* List of monitored events */
#define CREATION_EV_SIGNAL_MASK (0x1)
#define KILLED_EVENT_SIGNAL_MASK (0x2)
#define TARGET_UNBIND_MASK  (0x3)

typedef enum stateTypes { RUN , STOP , PAUSE ,ACTIVE }stateTypes;


RT_TASK xrt_MainTask;
RT_TASK xrt_HostInterfaceTask;
RT_TASK xrt_BaseTask;
RT_TASK xrt_LoggerTask;

RTIME  xrt_BaseTaskPeriod;/*simulink model sampling period*/
RTIME  xrt_HostInterfacePeriod=100000000;
RTIME latency;


RT_HEAP name; 
RT_HEAP contheap_desc;
RT_HEAP heap_desc;
RT_QUEUE q_desc;
RT_EVENT paramevent;
RT_EVENT e_timeElapsed;
RT_QUEUE q_desc3; 
RT_EVENT e_unbind; 
RT_EVENT gui_to;
 
 stateTypes targetState;

//RTIME period=1000000000
RT_COND  cond_desc;
RT_MUTEX mutex_desc;
RT_EVENT e_stopToStart;

void* shared_mem;
void* shm_mem2;

volatile uint_T cSigNum=10;

volatile int overrunChecker=0;

static float finaltime            = RUN_FOREVER;

static int shm_index=0;

static bool volatile terminate=0;





#ifdef EXT_MODE
#  define rtExtModeSingleTaskUpload(S)                          \
   {                                                            \
        int stIdx;                                              \
        rtExtModeUploadCheckTrigger(rtmGetNumSampleTimes(rtM)); \
        for (stIdx=0; stIdx<NUMST; stIdx++) {                   \
            if (rtmIsSampleHit(S, stIdx, 0 /*unused*/)) {       \
                rtExtModeUpload(stIdx,rtmGetTaskTime(S,stIdx)); \
            }                                                   \
        }                                                       \
   }
#else
#  define rtExtModeSingleTaskUpload(S) /* Do nothing */
#endif



extern RT_MODEL *MODEL();/* xrt_Main fonksiyonunda model_name ile belirtilen
                                parametreye geçirilecek argüman değişkeni*/                                                

static RT_MODEL *rtM;

/*RUN-AND-DEBUG----------------------------------------------------------*/

/*NO DATA SWAPPING TO DISK----------------------------------------------*/
void init_xenomai() {
 
	mlockall(MCL_CURRENT|MCL_FUTURE);
	rt_print_auto_init(1);
}


#ifndef EXT_MODE

/*UTILITY------------------------------------------------------------------*/

static inline void strncpyz(char *dest, const char *src, size_t n)
{
  if (src != NULL) {
    strncpy(dest, src, n);
    n = strlen(src);
  } else
    n = 0;
		
  dest[n] = '\0';
}
static inline void set_double(double *to, double *from)
{
  unsigned long l = ((unsigned long *)from)[0];
  unsigned long h = ((unsigned long *)from)[1];
  __asm__ __volatile__ (
			"1: movl (%0), %%eax; movl 4(%0), %%edx; lock; cmpxchg8b (%0); jnz 1b" : : "D"(to), "b"(l), "c"(h) : "ax", "dx", "memory");
}



#define RT_SET_PARAM_INFO_IF(rtcase, rttype) \
	case rtcase: \
             \
		if (xrtpi[paramIdx].isComplex==0) { \
			rttype *param = (rttype *) paramAddress;\
			 /*real_T *newParam  = (real_T *) (_newVal);*/\
                    \
			switch (xrtpi[paramIdx].dataOrientation) { \
				case rtwCAPI_SCALAR: \
					 /**param = *newParam;*/\
                      *param= xrtpi[paramIdx].dataValue[0]; \
					 \
                  break;\
				case rtwCAPI_VECTOR: \
					for (colIdx = 0; colIdx < xrtpi[paramIdx].numRows*xrtpi[paramIdx].numColumns; colIdx++) { \
						/*param[rowIdx] = newParam[rowIdx]; */\
						  param[colIdx] = xrtpi[paramIdx].dataValue[colIdx] ;\
					} \
					break; \
				case rtwCAPI_MATRIX_ROW_MAJOR: \
					for(rowIdx = 0; rowIdx < xrtpi[paramIdx].numRows; rowIdx++){ \
						for(colIdx = 0; colIdx <xrtpi[paramIdx].numColumns; colIdx++) { \
							/*param[rowIdx*xrtpi[paramIdx].numColumns + colIdx] = newParam[rowIdx*xrtpi[paramIdx].numColumns + colIdx];*/ \
							 param[rowIdx*xrtpi[paramIdx].numColumns + colIdx]= xrtpi[paramIdx].dataValue[rowIdx*xrtpi[paramIdx].numColumns + colIdx];\
						} \
					} \
					break; \
				case rtwCAPI_MATRIX_COL_MAJOR: \
					for(rowIdx = 0; rowIdx < xrtpi[paramIdx].numRows; rowIdx++)  { \
						 for(colIdx = 0; colIdx < xrtpi[paramIdx].numColumns; colIdx++){ \
							/*param[colIdx*xrtpi[paramIdx].numRows + rowIdx] = newParam[colIdx*xrtpi[paramIdx].numRows + rowIdx];*/ \
							param[colIdx*xrtpi[paramIdx].numRows + rowIdx]= xrtpi[paramIdx].dataValue[colIdx*xrtpi[paramIdx].numRows+ rowIdx]; \
						} \
					} \
					break; \
                                case rtwCAPI_MATRIX_COL_MAJOR_ND: \
					break; \
				default: \
					return(1); \
			} \
		} \
		break;					 





/*SET SIMULINK BLOCK PARAMETERS----------------------------------------*/

int_T 	 Xrt_SetParameterInfo(void *rtw_mpi)

{
  rtwCAPI_ModelMappingInfo*      capiMap;
  const rtwCAPI_BlockParameters* blockParams;
  const rtwCAPI_DataTypeMap*     dataTypeMap;
  void* paramAddress;
   void**                         dataAddrMap;
  uint_T nRows;
  uint_T nCols;
  uint_T nParams;
  uint_T rowIdx;
  uint_T colIdx;
  uint_T addrIdx;
  uint_T paramIdx;
  
 capiMap      = (rtwCAPI_ModelMappingInfo *)rtw_mpi;
 
  int nBlockParams=rtwCAPI_GetNumBlockParameters(capiMap);
 
 
 blockParams  =rtwCAPI_GetBlockParameters(capiMap);

    
 for(paramIdx=0;paramIdx<nBlockParams;paramIdx++) {
  /* Get the address to this parameter                     */
   dataAddrMap = rtwCAPI_GetDataAddressMap(capiMap);
    addrIdx     = rtwCAPI_GetBlockParameterAddrIdx(blockParams,paramIdx);
    paramAddress= (void *) rtwCAPI_GetDataAddress(dataAddrMap,addrIdx); 
      

   switch ( xrtpi[paramIdx].dataType) {


     RT_SET_PARAM_INFO_IF(SS_DOUBLE, real_T)
     RT_SET_PARAM_INFO_IF(SS_SINGLE, real32_T)
     RT_SET_PARAM_INFO_IF(SS_INT8, int8_T)
      RT_SET_PARAM_INFO_IF(SS_UINT8, uint8_T)
      RT_SET_PARAM_INFO_IF(SS_INT16, int16_T)
      RT_SET_PARAM_INFO_IF(SS_UINT16, uint16_T)
      RT_SET_PARAM_INFO_IF(SS_INT32, int32_T)
     RT_SET_PARAM_INFO_IF(SS_UINT32, uint32_T)
     RT_SET_PARAM_INFO_IF(SS_BOOLEAN, boolean_T)
     
default:
			    
               return -1;
}//switch




}//for


}

#define RT_GET_PARAM_INFO_IF(rtcase, rttype) \
	case rtcase: \
             \
		if (xrtpi[paramIdx].isComplex==0) { \
			rttype *param = (rttype *) paramAddress;\
			switch ( xrtpi[paramIdx].dataOrientation) { \
				case rtwCAPI_SCALAR: {\
					xrtpi[paramIdx].dataValue[0] = (double)*param;}\
					break; \
				case rtwCAPI_VECTOR: \
					for (colIdx = 0; colIdx < xrtpi[paramIdx].numRows*xrtpi[paramIdx].numColumns; colIdx++) { \
						xrtpi[paramIdx].dataValue[colIdx] = (double)param[colIdx]; \
						\
					} \
					break; \
				case rtwCAPI_MATRIX_ROW_MAJOR: \
					for(rowIdx = 0; rowIdx < xrtpi[paramIdx].numRows; rowIdx++){ \
						for(colIdx = 0; colIdx < xrtpi[paramIdx].numColumns; colIdx++) { \
							xrtpi[paramIdx].dataValue[rowIdx*xrtpi[paramIdx].numColumns + colIdx] = param[rowIdx*xrtpi[paramIdx].numColumns+colIdx]; \
						} \
					} \
					break; \
				case rtwCAPI_MATRIX_COL_MAJOR: \
					for(rowIdx = 0; rowIdx <  xrtpi[paramIdx].numRows; rowIdx++)  { \
						 for(colIdx = 0; colIdx < xrtpi[paramIdx].numColumns; colIdx++){ \
							xrtpi[paramIdx].dataValue[colIdx*xrtpi[paramIdx].numRows + rowIdx] = param[colIdx*xrtpi[paramIdx].numRows+ rowIdx]; \
						} \
					} \
					break; \
                                case rtwCAPI_MATRIX_COL_MAJOR_ND: \
					break; \
				default: \
					return(1); \
			} \
		} \
		break;					 




 
/*  *Get Parameter Information:-------------------------------------------------/
    *Model Name,
    *Block Name,
    *Parameter Name,
   *Number of Row,
    *Number of Column,
    *Data Type,
 /* *Data Orientation.-------------------------------------------------------*/	
 
int_T Xrt_GetParameterInfo(void *rtw_mpi){

  
    rtwCAPI_ModelMappingInfo*      capiMap; 
    const rtwCAPI_BlockParameters* blockParams;
    const rtwCAPI_DataTypeMap*     dataTypeMap;
    const rtwCAPI_DimensionMap*    dimMap;
    const rtwCAPI_FixPtMap*        fxpMap;
    const uint_T*                  dimArray;
    void**                         dataAddrMap;
    void* paramAddress;
    uint_T paramIdx;
    
   
 capiMap= (rtwCAPI_ModelMappingInfo *)rtw_mpi;

    const char_T* paramName;
    const char_T* blockName;
    uint_T        addrIdx;
    uint16_T      dataTypeIdx;
    uint16_T      dimIndex;
    uint16_T      fxpMapIdx;
    uint8_T       slDataID;

   
    const char_T*        cDataName;
    unsigned short       isComplex;
    uint8_T              numDims;
    uint_T               dimArrayIdx;
    rtwCAPI_Orientation  orientation;
    uint_T            actualDimensions[10];
    uint_T numRows;
    uint_T numColumns;  

    int    idx;
    real_T slope = 1.0;
    real_T bias  = 0.0;
    unsigned short modParamFlag = 0;

                    
    uint_T rowIdx;
    uint_T colIdx;
    uint_T pageIdx;
  uint_T nBlockParams;
  
 
      
   nBlockParams=rtwCAPI_GetNumBlockParameters(capiMap);
   controlHeap[5]=rtwCAPI_GetNumBlockParameters(capiMap);
   
/******************** GET Model Name **************************/ 
  
    for(paramIdx=0;paramIdx<nBlockParams;paramIdx++)
    strncpyz(xrtpi[paramIdx].modelName, STR(MODEL), MAX_NAMES_SIZE);
/**************************************************************/

  /* Assert the parameter index is less than total number of parameters */
 
    for(paramIdx=0;paramIdx<nBlockParams;paramIdx++)
    assert(paramIdx < rtwCAPI_GetNumBlockParameters(capiMap));

    /* Get blockParams, an array of rtwCAPI_ModelParameters structure  */
    blockParams = rtwCAPI_GetBlockParameters(capiMap);
    if (blockParams == NULL) return;
  
/********************GET Block Name**********************************************************/
  for(paramIdx=0;paramIdx<nBlockParams;paramIdx++)      
 strncpyz(xrtpi[paramIdx].blockName,rtwCAPI_GetBlockParameterBlockPath(blockParams,paramIdx), MAX_NAMES_SIZE);
/********************************************************************************************/
 
   

/***********************Get Parameters Names*****************************************************/
for(paramIdx=0;paramIdx<nBlockParams;paramIdx++) {
strncpyz(xrtpi[paramIdx].paramName,rtwCAPI_GetBlockParameterName(blockParams, paramIdx), MAX_NAMES_SIZE);
strncpyz(xrtpi[paramIdx].blockName,rtwCAPI_GetBlockParameterBlockPath(blockParams, paramIdx), MAX_NAMES_SIZE);
}
/**********************************************************************************************/


    /* Get Data Type attributes of the Model Parameter                       */
    /* Accessing the data type information from capiMap is a 3 step process  *
     * 1) Get the dataTypeMap Array from capiMap.                            *
     * 2) Get the index into the above array, dataTypeIdx, from ModelParameter*
     *    structure. The index will point to a rtwCAPI_DataTypeMap structure.*
     * 3) From the structure, get the member values of the structure, namely *
     *       o Simulink Data ID, can be one of the enumerated value          *
     *           SS_DOUBLE, SS_SINGLE, SS_INT8, SS_UINT8, SS_INT16, SS_UINT16*
     *            , SS_INT32, SS_UINT32, SS_BOOLEAN                          *
     *       o Complexity                                                    *
     *       o Data Size                                                     *
     *    For complete structure see matlabroot/rtw/c/src/rtw_capi.h         */

    dataTypeMap = rtwCAPI_GetDataTypeMap(capiMap);
    
    if (dataTypeMap == NULL) return;
    
      for(paramIdx=0;paramIdx<nBlockParams;paramIdx++){ 
      
    dataTypeIdx = rtwCAPI_GetBlockParameterDataTypeIdx(blockParams, paramIdx);
    slDataID    = rtwCAPI_GetDataTypeSLId(dataTypeMap, dataTypeIdx);

 /*************GET DATA TYPEs*************************************************/

 xrtpi[paramIdx].dataType=slDataID;        
/***************************************************************************/
    cDataName   = rtwCAPI_GetDataTypeCName(dataTypeMap,dataTypeIdx);
   xrtpi[paramIdx].isComplex   = rtwCAPI_GetDataIsComplex(dataTypeMap,dataTypeIdx);}

    /* Get Dimensions of the Model Parameter                                 */
    /* Accessing the dimension from capiMap is a 4 step process              *
     * 1) Get the dimMap array, an array of CAPI_DimensionMap struct         *
     * 2) Get the dimArray array, an array of all the dimensions in the Map  *
     * 3) Get the index into the dimMap array (dimIdx) from ModelParameter   *
     *    structure. the index will point to rtwCAPI_Dimension structure     *
     * 4) From the rtwCAPI_Dimension structure, get the following information*
     *       o orientation (scalar | vector | matrix)                        *
     *       o Number of dimensions (numDims)                                *
     *       o index into the dimArray (dimArrayIdx)                         *
     * 5) Using numDims and the dimArrayIdx, get the actual dimensions from  *
     *    the dimArray                                                       *
     *       uint_T ActualDims[numDims] = {dimArray[dimArrayIdx],            *
     *                                     dimArray[dimArrayIdx+1],          *
     *				       ...                                   *
     *				       dimArray[dimArrayIdx+(numDims-1)]}    *
     *    For e.g, scalar and 2-D parameters will have numDims = 2, So       *
     *       uint_T ActualDims[2] = {dimArray[dimArrayIdx],                  *
     *                               dimArray[dimArrayIdx +1]}               */
    
    
     //uint8_T             nDims  = rtwCAPI_GetNumDims(dimMap, dimIdx);
    //    uint_T              dIndex = rtwCAPI_GetDimArrayIndex(dimMap, dimIdx);
    
      //uint_T   addrIdx  =  rtwCAPI_GetSignalAddrIdx(bioSig,sigIdx);xrt_HostInterfaceTask
       // uint16_T dTypeIdx =  rtwCAPI_GetSignalDataTypeIdx(bioSig,sigIdx);
       // uint16_T dimIdx   =  rtwCAPI_GetSignalDimensionIdx(bioSig,sigIdx);
    
    
    
    
    dimMap   = rtwCAPI_GetDimensionMap(capiMap);
    dimArray = rtwCAPI_GetDimensionArray(capiMap);

    if ((dimMap == NULL) || (dimArray == NULL)) return;



for(paramIdx=0;paramIdx<nBlockParams;paramIdx++) {

    dimIndex    = rtwCAPI_GetBlockParameterDimensionIdx(blockParams, paramIdx);
    numDims     = rtwCAPI_GetNumDims(dimMap, dimIndex); 
    
    //actualDimensions=(uint_T *) calloc(numDims, sizeof(uint_T));
    
    dimArrayIdx = rtwCAPI_GetDimArrayIndex(dimMap, dimIndex);
    orientation = rtwCAPI_GetOrientation(dimMap, dimIndex);
  /******************************* GET ORIENTATIONs******************************/
   xrtpi[paramIdx].dataOrientation=orientation;
   for(idx=0; idx < numDims; idx++) {
        actualDimensions[idx] = dimArray[dimArrayIdx + idx];
         //printf("actdim::%d\n",actualDimensions[idx]);
    }
   xrtpi[paramIdx].numRows=actualDimensions[0];
   xrtpi[paramIdx].numColumns=actualDimensions[1];
   
    //free(actualDimensions);
    //printf("orient::%d,%d\n",xrtpi[paramIdx].dataOrientation,paramIdx);
    // printf(" t param numRows,cols::%d %d\n",xrtpi[paramIdx].numRows,xrtpi[paramIdx].numColumns);
   }
  /*****************************************************************************/



          

    /* Get fixed-point information of the parameter */
    fxpMap = rtwCAPI_GetFixPtMap(capiMap);
    if (fxpMap == NULL) return;
    
    fxpMapIdx = rtwCAPI_GetBlockParameterFixPtIdx(blockParams, paramIdx);
    if(fxpMapIdx > 0) {
        /* Only Fixed-point parameters have fxpMapIdx > 0 */
        real_T fracslope = rtwCAPI_GetFxpFracSlope(fxpMap,fxpMapIdx);
        int8_T expt      = rtwCAPI_GetFxpExponent(fxpMap,fxpMapIdx);
        
        /* slope = fractional slope * 2^exponent 
         * fractional slope is also called Slope Adjustment Factor. 
         * Type "help fixdt" in MATLAB command window for more information
         * on fixed point data types  
         */
        
        slope = fracslope*pow(2.0,expt);
        bias  = rtwCAPI_GetFxpBias(fxpMap,fxpMapIdx);
    }

  
   

    
printf("get param.\n");
 
 for(paramIdx=0;paramIdx<nBlockParams;paramIdx++) {
  /* Get the address to this paxeno_Starrameter                     */
   dataAddrMap = rtwCAPI_GetDataAddressMap(capiMap);
    addrIdx     = rtwCAPI_GetBlockParameterAddrIdx(blockParams,paramIdx);
    paramAddress= (void *) rtwCAPI_GetDataAddress(dataAddrMap,addrIdx); 



uint_T numPages = 0;
    if (numDims == 3) numPages = actualDimensions[2];
    


  
   
  switch ( xrtpi[paramIdx].dataType) {


     RT_GET_PARAM_INFO_IF(SS_DOUBLE, real_T)
     RT_GET_PARAM_INFO_IF(SS_SINGLE, real32_T)
      RT_GET_PARAM_INFO_IF(SS_INT8, int8_T)
      RT_GET_PARAM_INFO_IF(SS_UINT8, uint8_T)
      RT_GET_PARAM_INFO_IF(SS_INT16, int16_T)
      RT_GET_PARAM_INFO_IF(SS_UINT16, uint16_T)
      RT_GET_PARAM_INFO_IF(SS_INT32, int32_T)
      RT_GET_PARAM_INFO_IF(SS_UINT32, uint32_T)
      RT_GET_PARAM_INFO_IF(SS_BOOLEAN, boolean_T)
      
default:
{ //free(actualDimensions);	
               return -1;}
}//switch
}//for



 //free(actualDimensions);
 return 0;
}//END 

#endif


   RTIME currentTime,pastTime,now,previous,basePeriod;
   RTIME baseElapsed=0;


void xrt_Base(void*arg);


#ifndef EXT_MODE
/* CREATE SHARED MEMORY for PARAMETERS-------------------------------------------*/
void init_shmBlockParameters(){
int err;
 rtwCAPI_ModelMappingInfo* mmi;
     
 mmi = &(rtmGetDataMapInfo(rtM).mmi);

  if (mmi == NULL) {
        printf(" MMI NULL!!\n");
      return -1;
  }
 uint_T nBlockParams;
  
   nBlockParams=rtwCAPI_GetNumBlockParameters(mmi);
     printf("parametre sayısı=%d",nBlockParams);
   
   
err=rt_heap_create(&name,"MODELNAME",sizeof(XrtModelName),H_SHARED); 
err=rt_heap_alloc(&name,sizeof(XrtModelName),TM_NONBLOCK,&shared_name);
if (err<0){
 printf("nameheap :: alloc failure!\n");
}



modelNm=(XrtModelName*)shared_name;

strncpyz(modelNm[0].modelName, STR(MODEL), MAX_NAMES_SIZE);   


        char buffer2[ NAMELENGTH ];
      snprintf(buffer2,NAMELENGTH,"%s%s",STR(MODEL),"_shm_blockparams");



   
 
 //printf("nBlockParams :%d\n",sizeof( XrtTargetParamInfo)
// );





err=rt_heap_create(&heap_desc,buffer2,sizeof( XrtTargetParamInfo)*nBlockParams,H_SHARED);
if (err<0){
 printf("heap :: creation failure!\n");
 
}
     
err=rt_heap_alloc(&heap_desc,sizeof( XrtTargetParamInfo)*nBlockParams,TM_NONBLOCK,&shared_mem);
if (err<0){
 printf("heap :: alloc failure!\n");
}
xrtpi=(XrtTargetParamInfo*)shared_mem;

   snprintf(buffer2,NAMELENGTH,"%s%s",STR(MODEL),"_controlheap");

err=rt_heap_create(&contheap_desc,buffer2,sizeof(double)*10,H_SHARED); 
err=rt_heap_alloc(&contheap_desc,sizeof(double)*10,TM_NONBLOCK,&sharedcon_mem);
if (err<0){
 printf("CONTROLheap :: alloc failure!\n");
}

controlHeap=(double*)sharedcon_mem;


}


RT_QUEUE q_desc1;
RT_QUEUE q_desc2;


  
   
   
   
   
   
   /************HOSTINTERFACE***************************/
   
   
 
   


      int logCoeff=1;




static double initTime=0;



void xrt_Logger(void* arg){

int i;
char  fileName[81];



for(i=0;i<sbInfo->numSigBufs;i++)
{

	snprintf(fileName,"%s_%s_%d.m",STR(MODEL),sigBufs[i].sigName,fileDesc++);
	
	
xeno_ContinuousLogging(fileName,i);




	}
}





















void xrt_HostInterface(void *arg){


  
    char receiveBuffer[MAX_BUFFER_SIZE];
    char rtxBuffer[MAX_BUFFER_SIZE];     
   
    char sendBuffer[MAX_BUFFER_SIZE];

if (firstRun==false)
{


  rt_queue_unbind(&q_desc1);
     rt_queue_unbind(&q_desc2);
        rt_queue_unbind(&q_desc3);




}


rtwCAPI_ModelMappingInfo* mmi;
   mmi = &(rtmGetDataMapInfo(rtM).mmi);
  
RT_TASK_INFO info;

  iopl(3);


/******TRY CONNECT TO HOST***************ev**/
rt_printf("trying to connect to the host...%d\n",firstRun);
int err;
/*err=rt_event_bind(&e_stopToStart,"startToStop",TM_INFINITE);

if (err==0)
 	rt_printf(" stop-->start event bind success !!%d\n",NULL);
       else 
rt_printf("event bind failed !!%d\n",NULL);

*/


    
  /***TRY CONNECT TO HOST*/
      size_t readByte;
  
    
    
    
    
    char buffer2[ NAMELENGTH ];
      snprintf(buffer2,NAMELENGTH,"%s%s",STR(MODEL),"_rtxenolab");
       if(rt_queue_bind(&q_desc3,buffer2,TM_INFINITE)){
        rt_printf("connection failed:target-rtxenolab ::%s\n",strerror(err));
//return;

}
     /*if(!rt_event_bind(&gui_to,"gereksiz",TM_INFINITE));
     rt_printf("gereksiz sucess\n");
     */
    else 
      rt_printf("connected1!\n");
    
      char buffer[ NAMELENGTH ];
     snprintf(buffer,NAMELENGTH,"%s%s",STR(MODEL),"GUIToTarget");
     err = rt_queue_bind(&q_desc1,buffer,TM_INFINITE);
     if(err){
        rt_printf("connection failed:GUIToTarget::%s\n",strerror(err));
//return;

}


else
            rt_printf("connected2!:%d\n",firstRun);

    
      snprintf(buffer2,NAMELENGTH,"%s%s","modelName_","TargetToGUI");
      //err = rt_queue_bind(&q_desc2,buffer2,TM_INFINITE);
                  if(err){
        //rt_printf("connection failed:TargetToGUI::%s\n",strerror(err));
//return;
}
          else
            rt_printf("connected3!\n");
            bindedToHost = true;
    
   
     strcpy(sendBuffer,TIME_ELAPSED);

    int retval;
      char message[32];
   snprintf(message,NAMELENGTH,"%s%s","modelName_","motor");


 


  

   if (firstRun==true){ 
    rt_queue_read(&q_desc1,receiveBuffer,MAX_BUFFER_SIZE,TM_INFINITE);
   
    if( strcmp ( receiveBuffer ,MODELNAME_STORED ) == 0 )
                {rt_printf("MODEL NAME SENT SUCCESSFULLY.\n");
                      rt_heap_free(&name,shared_name);
                      rt_heap_delete(&name);
                      
                     }
   }
  
   
 /***************************************************/   

 
  
  
 if (firstRun==true){
 
    Xrt_GetParameterInfo(mmi);
 //rt_printf("paused\n");
 //pause();
 
 }
 
 
 
 
 
    
    uint_T nBlockParams;
  
   nBlockParams=rtwCAPI_GetNumBlockParameters(mmi);
    
   int i;
   
   
   
     unsigned long mask_ret;  
 
        void**                         dataAddrMap;



 rt_task_set_periodic(NULL,TM_NOW,1000000);
 
 endHostInterface=0;
 endBaseRate=0;
targetState=STOP;
    unsigned long mask_ret2;
     unsigned long mask_r=0;
rt_printf("hostum ben \n");
targetState = STOP;
while(!endHostInterface){

//rt_printf(xrt_B)
rt_task_wait_period(NULL);
        //rt_event_bind(&e_stopToStart,"startToStop",TM_INFINITE);
  //rt_printf("hostum ben dön baba dön\n");
   readByte = rt_queue_read(&q_desc1,receiveBuffer,MAX_BUFFER_SIZE,TM_NONBLOCK);
   readByte = rt_queue_read(&q_desc3,rtxBuffer,MAX_BUFFER_SIZE,TM_NONBLOCK);

           
//Q8AnalogConfig(0,2,2);
  //  Q8AnalogOutput(0,2,6.5);
 Xrt_SetParameterInfo(mmi);
       
         if( strcmp ( receiveBuffer ,STOP_TARGET ) == 0 ){
            
           rt_printf("Targett Sopped\n");
             if(susp==true)
              rt_task_resume(&xrt_BaseTask);
              susp=false;
              //printf("I am stop:end flag: %d ,%d",endHostInterface,endBaseRate );
          /*    if (fd>=0);
              {Q8Close(fd);
                
  rt_printf("q8 is closing...)
}*/



              endBaseRate=1;
              targetState=STOP;
              terminate=0;
         
              rt_task_join(&xrt_BaseTask);
    
              //rtmSetStopRequested(rtM,true);
              rt_task_delete(&xrt_BaseTask);
               controlHeap[0]=0;
              endHostInterface=1;
             TERMINATE(rtM);
               //rt_queue_read(&q_desc1,receiveBuffer,MAX_BUFFER_SIZE,TM_INFINITE);
                //if( strcmp ( receiveBuffer ,UNBIND_FROM_HOST ) == 0 ){
          
                bindedToHost=false;
             rt_printf("Targett Sopped\n");
               
              }
         
        else   if( strcmp ( receiveBuffer ,START_TARGET ) == 0 && firstRun ==true && targetState!=RUN){
       
       START(rtM);
       
        if (rtmGetErrorStatus(rtM) != NULL) {
    fprintf(stderr, "Failed in target initialization.\n");
    TERMINATE(rtM);
    fprintf(stderr, "Target ixrt_BaseTaskPeriods terminated.\n");
        printf(stderr, "Target is terminated.\n");
     printf("Target is terminated.\n");   
       clean_up();
       return 0;
  }  

        endBaseRate=0;
        targetState=RUN;
        firstRun=false;
        
         rt_task_spawn(&xrt_BaseTask,"Computing",0,99,T_JOINABLE|T_FPU|T_CPU(3)|T_JOINABLE,xrt_Base,NULL);
           
        }
                  
        else   if( strcmp ( receiveBuffer ,START_TARGET ) == 0  &&  targetState== PAUSE){
//receiveBuffer[0]='\0';
        endBaseRate=0;
        targetState=RUN;
        //susp=false;
        rt_task_resume(&xrt_BaseTask);
        
        }
              
          else   if( strcmp ( receiveBuffer ,START_TARGET ) == 0 && (targetState==STOP)){ 
           START(rtM); 
            if (rtmGetErrorStatus(rtM) != NULL) {
    fprintf(stderr, "Failed in target initialization.\n");
    TERMINATE(rtM);
    fprintf(stderr, "Target is terminated.\n");
        printf(stderr, "Target is terminated.\n");
     printf("Target is terminated.\n");   
       clean_up();
       return 0;
  }  

            sbInfo->numDataPoints=0;
            rtmSetSampleTimePtr(rtM, &controlHeap[2] );
            rtmSetSampleTime(rtM, 0, (double)controlHeap[2] );
            rtmSetStepSize(rtM,(double)controlHeap[2]);
                    
                      //rtmSetStopRequested(rtM,false); 
                     controlHeap[0]=0;
           //xeno_StartBlockIOLogging(mmi, MAX_LOG_POINTS);
           endBaseRate=0;
        targetState=RUN;
        rtmSetTFinal(rtM, (real_T)controlHeap[1]);
         //rt_printf("Final time: %f dur: %f now:%f \n",rtmGetTFinal(rtM),controlHeap[1],controlHeap[0]);
        
        //firstRun=false;
        //rtmSetStartTime(rtM,0);
        rt_task_spawn(&xrt_BaseTask,"Computing",0,99,T_JOINABLE|T_FPU|T_CPU(3)|T_JOINABLE,xrt_Base,NULL);
       
          }    
              
           else   if( strcmp ( receiveBuffer ,PAUSE_TARGET ) == 0 && targetState == RUN){
    //             receiveBuffer[0]='\0';
                  //pauseFlag=1;
                  //baseElapsed=previous;
                 
                  targetState=PAUSE;
                  susp=true;
                  rt_task_suspend(&xrt_BaseTask);
                     rt_printf("HOST:RUN->pause:%d\n",overrunChecker);
                  }
                  
            else if ( strcmp ( receiveBuffer , UPDATE_FREQDUR ) == 0 && (targetState == STOP )){
      //      receiveBuffer[0]='\0';
             xrt_BaseTaskPeriod=(RTIME)((1000000000.0)*((controlHeap[2])));
              //rt_printf("logcoeef:%d\n",(int)controlHeap[3]);
             rtmSetStepSize(rtM,(controlHeap[2]));
            
            }
                  
  
      else   if( strcmp ( rtxBuffer ,HOST_TERMINATED ) == 0 ){
        //receiveBuffer[0]='\0';
        endBaseRate=1;
        endHostInterface=1;
        terminate =1;
        rt_printf("Target terminated..\n");
        
        }
        


 
   

}



}






#endif
 

 
#ifndef EXT_MODE
//overrunChecker=0;

void xrt_Base(void *arg){
     
     
  controlHeap[0]=0;   
modelTime=0;
     
     int err;
 unsigned long mask_ret;
unsigned long mask_r=0;  
int c;    

rt_printf("worhhk\n");

printf("worhhk\n");
RTIME realtime;     
RT_TASK_INFO taskinfo;
 
  int finalstep=0;
  real_T tnext;
  char myname[7];
 
 // int rt_BaseRateTaskPriority = *((int *)arg);
  
  
  
   rtwCAPI_ModelMappingInfo* mmi;
  mmi = &(rtmGetDataMapInfo(rtM).mmi);
 
  
  iopl(3);
   /*err = rt_event_wait(&SigBase_event_desc,
                        CREATION_EV_SIGNAL_MASK ,
                        &mask_ret,
                        EV_ANY,
                        TM_INFINITE);
                        if (err<0)
                        rt_printf(" SB event wait err\n");
  
  rt_printf("SB event detected\n");*/
  //rt_event_clear(&SigBase_event_desc,mask_ret,&mask_r);
 //rt_printf("I VE run again\n");
   //capi_StartBlockIOLogging(mmi,MAX_DATA_POINTS);
   
   
   //rtmSetTimePtr(rtM,(real_T*)&modelTime);
     
    
  
 logCoeff=(int)controlHeap[3];
  int i=logCoeff;
   //xeno_UpdateBlockIOLogging(mmi,&modelTime);
  
   rt_task_set_periodic(NULL,TM_NOW, xrt_BaseTaskPeriod);
   
   previous=rt_timer_read(); 
  rt_printf("Final time: %f\n",rtmGetTFinal(rtM));
  
  checkBegin=0;
  checkEnd=0;
 
 
 
 
 
 //rtmSetTPtr(rtM,&modelTime);
 //rtmSetTimePtr(rtM,&modelTime);
 modelTime=0;
 
  
  while (!endBaseRate && !(rtmGetTFinal(rtM) != RUN_FOREVER && (rtmGetTFinal(rtM) - /*rtmGetT(rtM)*/ controlHeap[0]) <= /*rtmGetT(rtM)*/controlHeap[0]*DBL_EPSILON)) {
 rt_task_wait_period(NULL);
pastTime=rt_timer_read();

 //rt_printf("basetest\n");


// while ( !(rtmGetTFinal(rtM) != RUN_FOREVER && (rtmGetTFinal(rtM) - /*rtmGetT(rtM)*/ rtmGetT(rtM)) <= /*rtmGetT(rtM)*/rtmGetT(rtM)*DBL_EPSILON)) {
  
  oc++;
  overrunChecker++;

 /*if (overrunChecker !=1)
  {   
      rt_printf("Overrun happened.");
      return;
 }*/
 




if (targetState!=PAUSE)

{


  
 if(rtmGetErrorStatus(rtM)!=NULL)
  
  return;
  
  
 
  
  
tnext = rt_SimGetNextSampleHit();
   rtsiSetSolverStopTime(rtmGetRTWSolverInfo(rtM), tnext);
    //Q8EncoderReset(0,6);
 //Q8EncoderReset(0,7);
  //Q8AnalogOutput(0,2,6.5);
    OUTPUTS(rtM, 0);
//Q8EncoderInput(0,6);
  //  Q8EncoderInput(0,7);
    
   logCoeff--;
   if(logCoeff==0){
   
xeno_UpdateBlockIOLogging(mmi,rtmGetTPtr(rtM)/*&modelTime*/);
   logCoeff=i;}
 
   
   UPDATED(rtM, 0);
   
    
    controlHeap[0]=rtmGetT(rtM);
    rt_SimUpdateDiscreteTaskSampleHits(rtmGetNumSampleTimes(rtM), rtmGetTimingData(rtM), rtmGetSampleHitPtr(rtM), rtmGetTPtr(rtM));
    if (rtmGetSampleTime(rtM,0) == CONTINUOUS_SAMPLE_TIME) {
          rt_UpdateContinuousStates(rtM);
    
   }
   
   
   now=rt_timer_read();
      
   
   //modelTime+=((double)(now-previous)/(1000000000));

   
   previous=now;
   
   //controlHeap[0]=modelTime;
   
     //xeno_UpdateBlockIOLogging(mmi,rtmGetTPtr(rtM));
  
}


else{

now = rt_timer_read();
previous = now;

}
oc--;
  //checkEnd=rt_timer_read();
   overrunChecker--;
latency=pastTime-rt_timer_read();
if((rt_timer_ticks2ns(latency)/1000)< -20.0)
rt_printf("TOTAL LOOP TIMING=%lld us\n", rt_timer_ticks2ns(latency)/1000);

   //rt_task_inquire(NULL,&taskinfo);xrt_HostInterfaceTask
}//while
//rt_task_inquire(NULL,&taskinfo);  
//rt_printf("modeswitches=%f\n",((&taskinfo)->modeswitches));
//rt_printf("page=%d\n",(&taskinfo)->pagefaults);


rt_printf("OVERRUN=%d\n",oc);


sbInfo->numDataPoints=0;

if(!endBaseRate){
//rt_queue_write(&q_desc2,sendBuffer,MAX_BUFFER_SIZE,Q_NORMAL);
 if(!rt_event_signal(&e_timeElapsed,TEVENT_SIGNAL_MASK))
rt_printf("event signal success:%d.\n",endBaseRate);}

//rt_printf("modeswitch=%d\n",(&taskinfo)->modeswitches);
//rt_printf("xrt_Base ended:%f\n",controlHeap[0]);
//xeno_StopBlockIOLogging("xenoSignalLog.txt");

           /*if (fd>=0);
              {Q8Close(fd);
                
  rt_printf("q8 is closing...)
}
    */
rt_printf("TERM\t\n");
    TERMINATE(rtM);                          
}


#endif







void init_task(){

//rt_task_spawn(&xrt_HostInterfaceTask,"Uploading",0 , 98,T_JOINABLE,xrt_HostInterface,NULL);

//rt_task_spawn(&xrt_BaseTask,"Computing",0,99,T_JOINABLE,xrt_Base,NULL);


} 


 

#ifndef EXT_MODE



/*GARBAGE COLLECTION-------------------------------------------------------*/
void clean_up(){
if (cleaned ==false){


//clean_Signals();
rt_event_delete(&e_timeElapsed);
rt_event_delete(&e_unbind);
rt_heap_free(&heap_desc,shared_mem);
rt_heap_delete(&heap_desc);
//rt_heap_free(&name,shared_name);
//rt_heap_delete(&name);
rt_task_delete(&xrt_BaseTask);
rt_task_delete(&xrt_HostInterfaceTask);
rt_task_delete(&xrt_LoggerTask);
rt_queue_unbind(&q_desc1);
rt_queue_unbind(&q_desc2);
rt_queue_unbind(&q_desc3);
printf("cleaned!\n");

cleaned=true;

}


}


#endif

#ifdef EXT_MODE

void clean_up(){}
#endif


static int_T xrt_Main(RT_MODEL* (*model_name)(void),int_T priority,int_T portNumber)

{
        
 const char* status;
 
              
rt_InitInfAndNaN(sizeof(real_T));
  
rtM = model_name();/*RT_MODEL tipindeki "model" veriyapısı değişkene atanıyor*/  
        if (rtM != NULL)
            printf("rtm null degil\n");
if (rtM == NULL) {
        fprintf(stderr,"Memory allocation error during model "
                      "registration");
         printf("Target is terminated.\n");   
       clean_up();
       exit(EXIT_FAILURE);/*????????*/
    }
        
  if (rtmGetErrorStatus(rtM) != NULL) {
    fprintf(stderr, "Error during model registration: %s.\n", rtmGetErrorStatus(rtM));
      printf("Target is terminated.\n");
      TERMINATE(rtM);   
       clean_up();
       exit(EXIT_FAILURE);}




       
  if (finaltime >= 0.0 || finaltime  == RUN_FOREVER) {
        //rtmSetTFinal(rtM, (real_T)finaltime);        //Custom Final Time Adjusting
    }
 
         
printf("initsizes is doing..\n");
printf("intsample is doing..\n") ;
         
  

 INITIALIZE_SIZES(rtM);
 INITIALIZE_SAMPLE_TIMES(rtM);
 
printf("initsizes done\n");
printf("intsample done\n");
    
int err;
         
 status = rt_SimInitTimingEngine(rtmGetNumSampleTimes(rtM),
                                    rtmGetStepSize(rtM),
                                    rtmGetSampleTimePtr(rtM),
                                    rtmGetOffsetTimePtr(rtM),
                                    rtmGetSampleHitPtr(rtM),   
                                    rtmGetSampleTimeTaskIDPtr(rtM),
                                    rtmGetTStart(rtM),
                                    &rtmGetSimTimeStep(rtM),
                                    &rtmGetTimingData(rtM));       
         
    if (status != NULL) {
        fprintf(stderr,
            "Failed to initialize sample time engine: %s\n", status);
     printf("Target is terminated.\n");   
       clean_up();
        exit(EXIT_FAILURE);
    }     
         
   
  rt_CreateIntegrationData(rtM);
  
    
         printf("Integration data created!\n");
         (void)printf("\n** starting the model **\n");

 // Q8EncoderConfig(0,6,0,0,3,0,0);
  //Q8EncoderConfig(0,7,0,0,3,0,0);
  //START(rtM); 
          
              
 if (rtmGetErrorStatus(rtM) != NULL) {
    fprintf(stderr, "Failed in target initialization.\n");
    TERMINATE(rtM);
    fprintf(stderr, "Target is terminated.\n");
        printf(stderr, "Target is terminated.\n");
     printf("Target is terminated.\n");   
       clean_up();
       return 0;
  }

 
printf("helooo\n");


           #ifndef EXT_MODE    

  rtwCAPI_ModelMappingInfo* mmi;
  mmi = &(rtmGetDataMapInfo(rtM).mmi);
  
  if (mmi!=NULL)
  printf("MMI OK\n");

#endif  

         
        if (firstRun==true)
         init_shmBlockParameters();
         
         
         
        

   if (firstRun==true)
 xeno_StartBlockIOLogging(mmi, MAX_LOG_POINTS);
         //cleaned=false;}


 #ifndef EXT_MODE
 if(firstRun==true)
 controlHeap[1]=rtmGetTFinal(rtM);
 #endif




//rtwCAPI_ModelMappingInfo* mmi;
//mmi = &(rtmGetDataMapInfo(rtM).mmi);

#ifndef EXT_MODE
  
//xeno_StartBlockIOLogging(mmi, MAX_LOG_POINTS); 

Xrt_GetParameterInfo(mmi);

int g;
/*for(g=0;g<2;g++)
printf("paramname:%s;val:%f\n",xrtpi[5].paramName,xrtpi[5].dataValue[g]);

*/
#endif
if(firstRun==true){
xrt_BaseTaskPeriod = (RTIME)(1000000000.0*rtmGetStepSize(rtM)); 

#ifndef EXT_MODE
controlHeap[2]=(double)(rtmGetStepSize(rtM));}
controlHeap[0]=0;
#endif   if (firstRun==true)
 //xeno_StartBlockIOLogging(mmi, MAX_LOG_POINTS);


//int err;
//rt_task_spawn(&xrt_LoggerTask,"Logger",0 , 97,T_JOINABLE|T_FPU|T_CPU(2),xrt_Logger,NULL);


//rt_task_shadow(&xrt_MainTask,"modelNameMainTask",1,0);

if (firstRun==true){
    err=rt_event_create(&e_timeElapsed,
			"timeElapsed",
			 EVENT_INIT,
		         EVENT_MODE);		

       if (err==0)
               printf("time elapsed event :create success\n");
       else
 printf("event :create failure!!\n");
  


  
}






if (fd<0)

fd = rt_dev_open(DEV_NAME, O_RDWR);


#ifndef EXT_MODE

//if (firstRun==true)

//err=rt_task_create(&xrt_LoggerTask,"xrt_Logger",0,95,T_JOINABLE|T_CPU(1));

//err=rt_task_create(&xrt_HostInterfaceTask,"Interface",0,98,T_JOINABLE|T_CPU(1));
err=rt_task_spawn(&xrt_HostInterfaceTask,"Interface",64*1024, 98,T_JOINABLE|T_CPU(1),xrt_HostInterface,NULL);


 

//rt_task_start(&xrt_HostInterfaceTask,xrt_HostInterface,NULL);
//printf("buraya gelir\n");
//pause();

#endif
      

//if (err<0)
//rt_task_shadow(&xrt_MainTask,"modelNameMainTask",1,0);
 //rt_task_set_periodic(NULL,TM_NOW, xrt_BaseTaskPeriod);
  /*while (!endex) {
    if (rtmGetTFinal(rtM) != RUN_FOREVER && (rtmGetTFinal(rtM) - rtmGetT(rtM)) <= rtmGetT(rtM)*DBL_EPSILON) {
      //if (Verbose){
	rt_printf("Final time occured.\n");
	break;
   // }
   }*/
   
  /*
    if (rtmGetErrorStatus(rtM) != NULL) {
      fprintf(stderr, "%s.\n", rtmGetErrorStatus(rtM));
      break;
    }
    //rt_timer_spin(30000000);///felaket üreticisi 
  }*/
//printf("task bekleniyor.\n");

//endHostInterface=1;
//rt_task_join(&xrt_BaseTask);fd = rt_dev_open(DEV_NAME, O_RDWR);

#ifndef EXT_MODE


rt_task_join(&xrt_HostInterfaceTask);
#endif
rt_task_delete(&xrt_HostInterfaceTask);
 //printf("Tasks ended:%d\n",firstRun);

  
  //clean_up();
  //rt_event_signal(&gui_to,0x9);
  //pause();
   //TERMINATE(rtM);
   firstRun=false;

  
          
 //printf("Overrun:%d\n",overrunChecker);
//clean_up();
       //printf("clean up done!!!\n");
       
      
return 0;
 
       
  }

/*
static void endme(int dummy)
{
  signal(SIGINT, endme);
  signal(SIGTERM, endme);
  endex = 1;
  clean_up();
       printf("clean up done!!!\n");
}*/

static void endme()
{
  endBaseRate=1;
  endHostInterface=1;
  rt_task_join(&xrt_HostInterfaceTask);
  rt_task_join(&xrt_BaseTask);
  terminate=1;
  if(cleaned==false){
    clean_up();
    cleaned=true;
       }
}
/*
void wait_for_ctrl_c() {

	signal(SIGTERM, catch_signal);
	signal(SIGINT, catch_signal);
	pause();
}*/



RT_EVENT killed_desc;
 

int main(int argc,char* argv[])

{
   cleaned=false;
    signal(SIGTERM, endme);
	signal(SIGINT, endme);
	signal(SIGKILL,endme);
   

             int err; 
             
     #ifndef EXT_MODE 

/* Here is where Q8 dirver is  loaded to kernel space */
     
//   system(STR(sudo insmod DQ8));
fd = rt_dev_open(DEV_NAME, O_RDWR);

if(fd<0)

 printf("target:Q8 device open error!\n");


  /* err=rt_event_create(&killed_desc,
			"targetkilled",
			 EVENT_INIT,
		         EVENT_MODE);		

       if (err==0)
               rt_printf("time elapsed event :create success\n");
       else
 rt_printf("event :create failure!!\n");
  */
     #endif
      
        //displayUsage();
        init_xenomai();
 #ifndef EXT_MODE         

 #endif
  
    targetState==STOP;
   

              
     

int c;

	//init_queue();
        //init_events();
        //init_task();

        //wait_for_ctrl_c();
        //endBaseRate=1;
       //rt_task_join(&xrt_BaseTask);
        //printf("clean up!!!\n");
        //while(!terminate)
    MODEL_INIT:
          
          
   
        c=  xrt_Main(MODEL,99,0);
          
          
     
          
          if(c==0 && terminate==0 && firstRun==false && targetState==STOP){
         
           c=-1;
            goto MODEL_INIT;
                          }
       

           if (fd>=0)
              {Q8Close(fd);
                
  printf("q8 is closing...\n");}

          if (cleaned==false)
       clean_up();
       //system(STR(sudo rmmod DQ8));
       //printf("clean up done!!!\n");
      //rt_event_signal(&killed_desc,KILLED_EVENT_SIGNAL_MASK);
       
      // rt_task_join(&xrt_HostInterfaceTask);
     
        //system(STR(sudo rmmod DQ8));
      TERMINATE(rtM);
       return 0;          
}
/* end of file */
